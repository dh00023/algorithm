## 정보과학과 문제

### 1. 계산 문제

수학적으로 계산 가능하며, 컴퓨터를 이용해 풀 수 있는 모든 문제들을 의미한다.

- **결정 문제(decision problem)**
- 탐색 문제(search problem)
- 카운팅 문제(counting problem)
- **최적화 문제(optimization problem)**
- 함수형 문제(function problem)

### 2. 결정 문제

계산 문제들 중 그 결과를 'YES' or 'NO'로 답할 수 있는 문제를 의미한다.

### 3. 최적화 문제

계산결과 얻은 후보 해들 중 가장 적절한 해를 찾는 형태의 문제를 말한다.

## 알고리즘과 실행시간 측정

### 1.알고리즘

주어진 문제를 해결하기 위한 단계 혹은 절차.
이 절차에는 입력값과 출력값이 존재해야하며, 유한한 단계를 거쳐서 반드시 종료되어야 한다.

알고리즘은 주로 자연어, 의사코드, 프로그래밍언어 등의 방법으로 기술할 수 있다.

#### 자연어
```
알고리즘 A
(1단계) 원소의 인덱스를 id로 정의한다.
(2단계) 집합 S에 대하여 1<=id<=n까지의 합을 구하고 이를 s라 한다.
(3단계) s를 출력하고 종료한다.
```

#### 의사코드(shudo code)

```
알고리즘 A
(1단계) id←1,s←0
(2단계) s = s + Sid, id ← id + 1
(3단계) id <= n goto 2단계
(4단계) print s
```

#### 프로그래밍 언어

```c
void A(int S, int n){
	int s = 0;
    for(int id = 1;id<=n;id++){
    	s = s + S[id];
    }
    printf("%d\n",s);
}
```

- 계산량 : n
- O(n)

알고리즘 효율성을 계산량으로 표현할 것이며, 계산량은 입력크기 n에 대한 실행시간을 나타낸다.

### 2. 실행시간의 측정

- 선택정렬(selection sort)는 자료가 10배 증가할수록 실행시간은 약 100배 증가한다. 따라서 n배커지면 n^2에 비례하여 증가한다.
- 퀵정렬(quick sort)는 백만개까지 정렬하는데 0.2초 이내로 처리하므로 알고리즘 효율의 차이를 직접 체감할 수 있음.
> 퀵정렬
> 1. pivot(기준값) 정하기
> 2. pivot보다 작은 원소들은 왼쪽, 큰 원소는 오른쪽
> 3. pivot을 기준으로 왼쪽 배열과 오른쪽 배열을 새로운 배열로 정하고 각 배열구간에서 1번과정 재귀적 반복
> 일반적으로 처음 또는 마지막 원소를 pivot으로 잡는다.

```cpp
// 퀵정렬 기반으로 동작하는 std::sort()사용
#include <algorithm>

std::sort()
```

- O(nlgn)으로 자료를 정렬하는 함수
- 배열,구조체, `std::vector`, `std::list`, `std::set`, `std::map`등 다양한 형태의 자료구조를 모두 정렬할 수있는 매우 강력한 정렬함수이다.

`std::sort(정렬할 자료의 시작 주소, 정렬할 자료의 마지막 주소,[비교함수 주소])`

```cpp
bool compare(int a, int b){
// 오름차순    return a<b;
// 내림차순
    return a>b;
}

bool comparep(POINT a, POINT b){
    if(a.x == b.x ) return a.y < b.y;
    else return a.x < b.x;
}

//처음부터 n-1번째까지 원소를 compare함수의 정의대로 정렬
std::sort(S,S+n,compare);
```
`compare`를 생략하면 오름차순

# 탐색기반 알고리즘 설계

탐색기반 설계방법은 문제를 탐색 가능한 형태로 구조화한 후 탐색해 나가는 알고리즘 설계방법이다.

##  탐색

탐색이란 같은 형태의 한 개 이상의 자료들이 적절한 형태로 구조화된 상태로 모여 있는 집합에서 특정 자료를 찾는 모든 작업을 말한다.
따라서 탐색할 자료가 저장되어 있는 **구조**를 파악하는 것이 중요하다.

- 선형구조(배열, 연결리스트로 표현될 수 있는 구조)
- 비선형구조(트리, 그래프 형태로 표현되는 구조)

탐색기반설계는 주어진 문제에서 주어진 데이터를 특성에 맞도록 구조화하고 이 자료를 적절한 방법으로 탐색해 나가면서 원하는 해를 찾는 알고리즘 설계법이다.

- 전체탐색법
- 부분탐색법(탐색할 영역을 적절한 방법으로 배제해 탐색의 효율을 높임)

### 1. 선형구조의 탐색

선형구조란 자료의 순서를 유일하게 결정할 수 있는 형태의 구조를 말한다. 2,3차원 구조라도 순서가 일정하게 정해져 있으면 이는 선형이라고 할 수 있다.

주로 **배열, 리스트**의 형태로 저장된다.

- 1차원 선형구조
- 다차원 선형구조(2차원 이상)

선형구조의 탐색은 선형구조로 저장된 자료들 중 원하는 것을 찾는 작업을 말한다.

- **순차탐색** : 자료의 특성에 관계없이 사용할 수 있는 일반적인 방법.
	- 전체탐색기법
	- O(n)
![](http://cfile30.uf.tistory.com/image/2133264853FDCD4C290295)

- **이분탐색**
	- O(log2 n)
	- 오름차순 or 내림차순으로 정렬된 선형구조에서 탐색

![](http://www.tipssoft.com/data/cheditor/0712/_copy9.gif)

`main`함수를 비롯한 모든 함수들은 함수 내에서 사용되는 모든 변수를 **지역변수**로 쓰는 것이 좋다.

전역변수는 지역변수보다 더 많은 공간을 확보할 수 있으며, 0으로 초기화된다.

- `lower_bound(S,S+n,k,[compare])`
- `upper_bound(S,S+n,k,[compare])`

### 2. 비선형구조의 탐색

**비선형구조**란 i번째 원소를 탐색한 다음 그 원소와 연결된 다른 원소를 탐색하려고 할 때, 여러 개의 원소가 존재하는 탐색구조를 말한다.

일반적으로 자료가 **트리**, **그래프**로 구성되어 있는 경우이다.

비선형구조의 탐색은 트리나 그래프의 모든 정점을 탐색하는 것이다.
비선형구조는 자료가 순차적으로 구성되어 있지 않으므로 단순히 반복문을 이용하기 어려우며 **스택**,**큐**같은 자료구조를 활용하여 탐색하는 것이 일반적이다.

- **깊이우선탐색(depth first search,dfs)**
- **너비우선탐색(breadth first search,bfs)**

![](http://cfile24.uf.tistory.com/image/23782C4E56AC1F3703588F)

정점은 일반적으로 상태나 위치를 표현한다. 간선은 정점들 간의 관계를 표현한다.

- 경로(path) : 정점s에서 임의의 정점t로 이동할 때, 사용한 정점들을 연결하고 있는 간선들의 순서로 된 집합
- 회로(cycle) : 그래프에서 임의의 정점s에서 같은 정점s로의 경로들

- 자기간선(loop) : 임의의 정점에서 자기 자신으로 연결하고 있는 간선
- 다중간선(multi edge) : 임의의 정점에서 다른 정점으로 연결된 간선의 수가 2개 이상
- 그래프의 차수(degree) : 임의의 한 정점에서 다늘 정점으로 연결된 간선의 수

#### 그래프의 구현

대표적인 입력형식은 첫 번째 줄에 정점의 수 n과 간선의 수 m
두번째 줄부터 간선으로 연결된 두 정점의 번호와 가중치
```
7 11
1 2 47
1 3 69
...
6 7 40
```

- 인접행렬(adjacency matrix)
	> 2차원 베열을 이용한다. 최대 정점의 수에 맞추어 2차원 배열 선언하고 각 ㅐ열의 칸에 연결된 정보 저장.

```cpp
#include <stdio.h>

int n, m, G[101][101];

int main(){
	scanf("%d %d",&n,&m);
	for(int i=0;i<m;i++)
    {
    	int a, b, w;
        scanf("%d %d %d",&a, &b, &w);
        G[a][b]=G[b][a]=w;
    }
}
```

- 인접리스트(adjacency list)